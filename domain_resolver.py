#!/usr/bin/env python3
"""
Domain to IP Address Resolver / 域名到IP地址解析器
A simple and maintainable tool for batch domain name resolution
简洁易维护的批量域名解析工具
"""

import socket
import sys
import argparse
from pathlib import Path
from concurrent.futures import ThreadPoolExecutor, as_completed
from typing import List, Dict, Optional


class DomainResolver:
    """
    Domain name to IP address resolver with parallel processing
    支持并行处理的域名到IP地址解析器
    """
    
    def __init__(self, max_workers: int = 10):
        self.max_workers = max_workers
    
    def resolve_single_domain(self, domain: str) -> Dict:
        """
        Resolve a single domain to IP address
        
        Args:
            domain: Domain name to resolve
            
        Returns:
            Dictionary containing resolution result
        """
        try:
            domain = domain.strip()
            if not domain or domain.startswith('#'):
                return None
            
            ip = socket.gethostbyname(domain)
            return {
                'domain': domain,
                'ip': ip,
                'status': 'success'
            }
        except socket.gaierror as e:
            return {
                'domain': domain,
                'ip': None,
                'status': 'failed',
                'error': str(e)
            }
    
    def load_domains_from_file(self, file_path: str) -> List[str]:
        """
        Load domain list from file
        
        Args:
            file_path: Path to domain list file
            
        Returns:
            List of domain names
        """
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                domains = [
                    line.strip() 
                    for line in f 
                    if line.strip() and not line.strip().startswith('#')
                ]
            return domains
        except FileNotFoundError:
            print(f"错误/Error: 找不到域名文件/Domain file '{file_path}' not found")
            return []
        except Exception as e:
            print(f"错误/Error: 读取文件失败/Reading file '{file_path}': {e}")
            return []
    
    def resolve_domains_parallel(self, domains: List[str]) -> List[Dict]:
        """
        Resolve multiple domains in parallel
        
        Args:
            domains: List of domain names
            
        Returns:
            List of resolution results
        """
        results = []
        
        with ThreadPoolExecutor(max_workers=self.max_workers) as executor:
            future_to_domain = {
                executor.submit(self.resolve_single_domain, domain): domain 
                for domain in domains
            }
            
            for future in as_completed(future_to_domain):
                result = future.result()
                if result:
                    results.append(result)
        
        return results
    
    def save_results(self, results: List[Dict], output_file: str) -> None:
        """
        Save resolution results to file
        
        Args:
            results: List of resolution results
            output_file: Output file path
        """
        with open(output_file, 'w', encoding='utf-8') as f:
            f.write("# Domain to IP Address Resolution Results / 域名到IP地址解析结果\n")
            f.write("# Generated by Domain Resolver / 由域名解析器生成\n\n")
            
            successful = [r for r in results if r['status'] == 'success']
            failed = [r for r in results if r['status'] == 'failed']
            
            # Write IP addresses only (for easy consumption by other tools)
            f.write("# IP Addresses Only / 仅IP地址列表:\n")
            for result in successful:
                f.write(f"{result['ip']}\n")
            
            # Write detailed mapping
            f.write(f"\n# Detailed Mapping / 详细映射 (成功/Success: {len(successful)}, 失败/Failed: {len(failed)}):\n")
            for result in results:
                if result['status'] == 'success':
                    f.write(f"{result['domain']} -> {result['ip']}\n")
                else:
                    f.write(f"{result['domain']} -> FAILED: {result['error']}\n")
    
    def print_summary(self, results: List[Dict]) -> None:
        """Print resolution summary to console"""
        successful = [r for r in results if r['status'] == 'success']
        failed = [r for r in results if r['status'] == 'failed']
        
        print(f"\n✅ 解析摘要/Resolution Summary:")
        print(f"   成功/Success: {len(successful)}")
        print(f"   失败/Failed:  {len(failed)}")
        print(f"   总计/Total:   {len(results)}")
        
        if successful:
            print(f"\n📋 成功解析/Successfully Resolved:")
            for result in successful:
                print(f"   {result['domain']} -> {result['ip']}")
        
        if failed:
            print(f"\n❌ 解析失败/Failed to Resolve:")
            for result in failed:
                print(f"   {result['domain']} -> {result['error']}")


def main():
    """Main function with command line argument parsing"""
    parser = argparse.ArgumentParser(
        description='Resolve domain names to IP addresses in batch / 批量解析域名到IP地址',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples / 使用示例:
  python domain_resolver.py
  python domain_resolver.py -i my_domains.txt -o my_ips.txt
  python domain_resolver.py --input domains.txt --output results.txt --workers 20
        """
    )
    
    parser.add_argument(
        '-i', '--input',
        default='domains.txt',
        help='输入域名文件/Input file containing domain names (default: domains.txt)'
    )
    
    parser.add_argument(
        '-o', '--output',
        default='ip_addresses.txt',
        help='输出IP地址文件/Output file for IP addresses (default: ip_addresses.txt)'
    )
    
    parser.add_argument(
        '-w', '--workers',
        type=int,
        default=10,
        help='并行工作线程数/Number of parallel workers (default: 10)'
    )
    
    parser.add_argument(
        '-v', '--verbose',
        action='store_true',
        help='启用详细输出/Enable verbose output'
    )
    
    args = parser.parse_args()
    
    # Initialize resolver
    resolver = DomainResolver(max_workers=args.workers)
    
    # Load domains
    if args.verbose:
        print(f"📂 正在加载域名文件/Loading domains from: {args.input}")
    
    domains = resolver.load_domains_from_file(args.input)
    
    if not domains:
        print("❌ 没有找到有效域名/No valid domains found")
        sys.exit(1)
    
    print(f"🔍 找到 {len(domains)} 个域名，开始解析/Found {len(domains)} domains to resolve...")
    
    # Resolve domains
    results = resolver.resolve_domains_parallel(domains)
    
    # Save results
    resolver.save_results(results, args.output)
    print(f"💾 结果已保存到/Results saved to: {args.output}")
    
    # Print summary
    resolver.print_summary(results)


if __name__ == "__main__":
    main()