#!/usr/bin/env python3
"""
Domain to IP Address Resolver / åŸŸååˆ°IPåœ°å€è§£æå™¨
A simple and maintainable tool for batch domain name resolution
ç®€æ´æ˜“ç»´æŠ¤çš„æ‰¹é‡åŸŸåè§£æå·¥å…·
"""

import socket
import sys
import argparse
from pathlib import Path
from concurrent.futures import ThreadPoolExecutor, as_completed
from typing import List, Dict, Optional


class DomainResolver:
    """
    Domain name to IP address resolver with parallel processing
    æ”¯æŒå¹¶è¡Œå¤„ç†çš„åŸŸååˆ°IPåœ°å€è§£æå™¨
    """
    
    def __init__(self, max_workers: int = 10):
        self.max_workers = max_workers
    
    def resolve_single_domain(self, domain: str) -> Dict:
        """
        Resolve a single domain to IP address
        
        Args:
            domain: Domain name to resolve
            
        Returns:
            Dictionary containing resolution result
        """
        try:
            domain = domain.strip()
            if not domain or domain.startswith('#'):
                return None
            
            ip = socket.gethostbyname(domain)
            return {
                'domain': domain,
                'ip': ip,
                'status': 'success'
            }
        except socket.gaierror as e:
            return {
                'domain': domain,
                'ip': None,
                'status': 'failed',
                'error': str(e)
            }
    
    def load_domains_from_file(self, file_path: str) -> List[str]:
        """
        Load domain list from file
        
        Args:
            file_path: Path to domain list file
            
        Returns:
            List of domain names
        """
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                domains = [
                    line.strip() 
                    for line in f 
                    if line.strip() and not line.strip().startswith('#')
                ]
            return domains
        except FileNotFoundError:
            print(f"é”™è¯¯/Error: æ‰¾ä¸åˆ°åŸŸåæ–‡ä»¶/Domain file '{file_path}' not found")
            return []
        except Exception as e:
            print(f"é”™è¯¯/Error: è¯»å–æ–‡ä»¶å¤±è´¥/Reading file '{file_path}': {e}")
            return []
    
    def resolve_domains_parallel(self, domains: List[str]) -> List[Dict]:
        """
        Resolve multiple domains in parallel
        
        Args:
            domains: List of domain names
            
        Returns:
            List of resolution results
        """
        results = []
        
        with ThreadPoolExecutor(max_workers=self.max_workers) as executor:
            future_to_domain = {
                executor.submit(self.resolve_single_domain, domain): domain 
                for domain in domains
            }
            
            for future in as_completed(future_to_domain):
                result = future.result()
                if result:
                    results.append(result)
        
        return results
    
    def save_results(self, results: List[Dict], output_file: str) -> None:
        """
        Save resolution results to file
        
        Args:
            results: List of resolution results
            output_file: Output file path
        """
        with open(output_file, 'w', encoding='utf-8') as f:
            f.write("# Domain to IP Address Resolution Results / åŸŸååˆ°IPåœ°å€è§£æç»“æœ\n")
            f.write("# Generated by Domain Resolver / ç”±åŸŸåè§£æå™¨ç”Ÿæˆ\n\n")
            
            successful = [r for r in results if r['status'] == 'success']
            failed = [r for r in results if r['status'] == 'failed']
            
            # Write IP addresses only (for easy consumption by other tools)
            f.write("# IP Addresses Only / ä»…IPåœ°å€åˆ—è¡¨:\n")
            for result in successful:
                f.write(f"{result['ip']}\n")
            
            # Write detailed mapping
            f.write(f"\n# Detailed Mapping / è¯¦ç»†æ˜ å°„ (æˆåŠŸ/Success: {len(successful)}, å¤±è´¥/Failed: {len(failed)}):\n")
            for result in results:
                if result['status'] == 'success':
                    f.write(f"{result['domain']} -> {result['ip']}\n")
                else:
                    f.write(f"{result['domain']} -> FAILED: {result['error']}\n")
    
    def print_summary(self, results: List[Dict]) -> None:
        """Print resolution summary to console"""
        successful = [r for r in results if r['status'] == 'success']
        failed = [r for r in results if r['status'] == 'failed']
        
        print(f"\nâœ… è§£ææ‘˜è¦/Resolution Summary:")
        print(f"   æˆåŠŸ/Success: {len(successful)}")
        print(f"   å¤±è´¥/Failed:  {len(failed)}")
        print(f"   æ€»è®¡/Total:   {len(results)}")
        
        if successful:
            print(f"\nğŸ“‹ æˆåŠŸè§£æ/Successfully Resolved:")
            for result in successful:
                print(f"   {result['domain']} -> {result['ip']}")
        
        if failed:
            print(f"\nâŒ è§£æå¤±è´¥/Failed to Resolve:")
            for result in failed:
                print(f"   {result['domain']} -> {result['error']}")


def main():
    """Main function with command line argument parsing"""
    parser = argparse.ArgumentParser(
        description='Resolve domain names to IP addresses in batch / æ‰¹é‡è§£æåŸŸååˆ°IPåœ°å€',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples / ä½¿ç”¨ç¤ºä¾‹:
  python domain_resolver.py
  python domain_resolver.py -i my_domains.txt -o my_ips.txt
  python domain_resolver.py --input domains.txt --output results.txt --workers 20
        """
    )
    
    parser.add_argument(
        '-i', '--input',
        default='domains.txt',
        help='è¾“å…¥åŸŸåæ–‡ä»¶/Input file containing domain names (default: domains.txt)'
    )
    
    parser.add_argument(
        '-o', '--output',
        default='ip_addresses.txt',
        help='è¾“å‡ºIPåœ°å€æ–‡ä»¶/Output file for IP addresses (default: ip_addresses.txt)'
    )
    
    parser.add_argument(
        '-w', '--workers',
        type=int,
        default=10,
        help='å¹¶è¡Œå·¥ä½œçº¿ç¨‹æ•°/Number of parallel workers (default: 10)'
    )
    
    parser.add_argument(
        '-v', '--verbose',
        action='store_true',
        help='å¯ç”¨è¯¦ç»†è¾“å‡º/Enable verbose output'
    )
    
    args = parser.parse_args()
    
    # Initialize resolver
    resolver = DomainResolver(max_workers=args.workers)
    
    # Load domains
    if args.verbose:
        print(f"ğŸ“‚ æ­£åœ¨åŠ è½½åŸŸåæ–‡ä»¶/Loading domains from: {args.input}")
    
    domains = resolver.load_domains_from_file(args.input)
    
    if not domains:
        print("âŒ æ²¡æœ‰æ‰¾åˆ°æœ‰æ•ˆåŸŸå/No valid domains found")
        sys.exit(1)
    
    print(f"ğŸ” æ‰¾åˆ° {len(domains)} ä¸ªåŸŸåï¼Œå¼€å§‹è§£æ/Found {len(domains)} domains to resolve...")
    
    # Resolve domains
    results = resolver.resolve_domains_parallel(domains)
    
    # Save results
    resolver.save_results(results, args.output)
    print(f"ğŸ’¾ ç»“æœå·²ä¿å­˜åˆ°/Results saved to: {args.output}")
    
    # Print summary
    resolver.print_summary(results)


if __name__ == "__main__":
    main()